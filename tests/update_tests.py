from ckl.functions import get_base_environment

# this script updates the tests/test_infotests.py file
# by scanning all entries in the base environment
# and inspecting the info string. If the string contains
# tests, then we add them to the test_infotests.py
# file.
#
# run this script anytime you change or add a test in
# an info string. After running the script, run the
# tests using pytest.

def main():
    with open("tests/test_infotests.py", "w", encoding="UTF-8") as outfile:
        print("# generated by tests/update_tests.py script, do not modify", file=outfile)
        print("from ckl.functions import get_none_environment", file=outfile)
        print("from ckl.interpreter import Interpreter", file=outfile)
        print("from ckl.values import ValueString", file=outfile)
        print("", file=outfile)
        print("interpreter = Interpreter(False, True)", file=outfile)
        print("", file=outfile)
        print("def run_test(test, expected):", file=outfile)
        print("    env = get_none_environment()", file=outfile)
        print("    result = interpreter.interpret(test, '{test}', environment=env)", file=outfile)
        print("    if not expected.startswith('<'):", file=outfile)
        print("        expected = interpreter.interpret(expected, '{info-test-expected}')", file=outfile)
        print("    else:", file=outfile)
        print("        expected = ValueString(expected)", file=outfile)
        print("    if expected.isString() and expected.value.startswith(\"'\"):", file=outfile)
        print("        expected = ValueString(expected[1:-1])", file=outfile)
        print("    if expected.isString() and not result.isString():", file=outfile)
        print("        result = result.asString();", file=outfile)
        print("    assert(result == expected)", file=outfile)
        print("", file=outfile)
        env = get_base_environment(False, True)
        for symbol in env.getSymbols():
            value = env.get(symbol)
            if not "info" in value.__dict__: continue
            info = value.info
            count = 1
            for line in info.splitlines():
                if not line.startswith(":"): continue
                test, expected = line[1:].split("==>")
                test = test.strip()
                expected = expected.strip()
                print(f"", file=outfile)
                print(f"def test_{symbol}_{count}():", file=outfile)
                print(f"    run_test({test!r}, {expected!r})", file=outfile)
                count += 1


if __name__ == "__main__":
    raise SystemExit(main())

